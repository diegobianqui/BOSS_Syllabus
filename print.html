<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bitcoin Core Development Study Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Part I: Bitcoin Core Architecture</a></li><li class="chapter-item expanded "><a href="cryptography.html"><strong aria-hidden="true">3.</strong> Part II: Cryptographic Foundations</a></li><li class="chapter-item expanded "><a href="wallets.html"><strong aria-hidden="true">4.</strong> Part III: Key Management & Wallets</a></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">5.</strong> Part IV: Transactions Deep Dive</a></li><li class="chapter-item expanded "><a href="taproot.html"><strong aria-hidden="true">6.</strong> Part V: Taproot & Modern Bitcoin</a></li><li class="chapter-item expanded "><a href="implementation.html"><strong aria-hidden="true">7.</strong> Part VI: Practical Implementation Patterns</a></li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">8.</strong> Appendix: Quick Reference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bitcoin Core Development Study Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/diegobianqui/BOSS_Syllabus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-this-guide-covers-"><a class="header" href="#what-this-guide-covers-">What This Guide Covers ‚úÖ</a></h2>
<p>This study guide synthesizes the multi-disciplinary knowledge required to understand Bitcoin at a professional development level. Rather than focusing purely on theory, it follows the architectural requirements of building a modern Bitcoin wallet. The journey is structured around four progressive technical challenges that mirror the complexities of the protocol.</p>
<p>First, we explore the internal architecture of a node to understand how it exposes data. Second, we dive into key management and the intensive process of scanning the blockchain for historical funds. Third, we master the creation of modern transactions using Taproot and Schnorr signatures. Finally, we address the economic optimization of Bitcoin through advanced coin selection and fee management.</p>
<h2 id="how-bitcoin-fits-together-"><a class="header" href="#how-bitcoin-fits-together-">How Bitcoin Fits Together ‚ö†Ô∏è</a></h2>
<p>Before diving into lines of code, one must establish a high-level mental model of the Bitcoin ecosystem. Bitcoin is not a single program but a stack of interacting layers. At its base sits the <strong>Consensus Layer</strong>, defining the immutable rules of the network. Above it, the <strong>Transaction and Script Layers</strong> define how value is locked and moved. Finally, the <strong>User Layer</strong> (wallets and interfaces) interacts with these rules to provide utility.</p>
<blockquote>
<p><strong>Correction</strong>: Modern Bitcoin Core has moved away from a monolithic structure toward a modular component model, explicitly separating validation logic from wallet and mempool management.</p>
</blockquote>
<pre><code class="language-mermaid">graph TB
    subgraph UserLayer["User Layer"]
        W[Wallet Software]
        A[Addresses]
    end
    
    subgraph CryptoLayer["Cryptographic Layer"]
        K[Keys - Private &amp; Public]
        S[Signatures]
        H[Hash Functions]
    end
    
    subgraph TransactionLayer["Transaction Layer"]
        TX[Transactions]
        UTXO[UTXOs]
        SC[Scripts]
    end
    
    subgraph ConsensusLayer["Consensus Layer"]
        B[Blocks]
        V[Validation Rules]
        N[Network Protocol]
    end
    
    subgraph CoreLayer["Bitcoin Core Components"]
        RPC[RPC/REST Interface]
        MEM[CTxMemPool]
        DB[BlockManager + LevelDB]
        SPKM[ScriptPubKeyMan]
    end
    
    W --&gt; K
    K --&gt; S
    S --&gt; TX
    TX --&gt; SC
    SC --&gt; UTXO
    UTXO --&gt; B
    B --&gt; DB
    RPC --&gt; MEM
    MEM --&gt; V
    SPKM --&gt; W
    
    style UserLayer fill:#e1f5fe,color:#000F00
    style CryptoLayer fill:#fff3e0,color:#000F00
    style TransactionLayer fill:#e8f5e9,color:#000F00
    style ConsensusLayer fill:#fce4ec,color:#000F00
    style CoreLayer fill:#f3e5f5,color:#000F00
</code></pre>
<h2 id="the-utxo-mental-model-"><a class="header" href="#the-utxo-mental-model-">The UTXO Mental Model ‚úÖ</a></h2>
<p>To develop for Bitcoin, one must unlearn the "Account" model used by traditional banks and Ethereum. Bitcoin doesn't have accounts; it has <strong>Unspent Transaction Outputs (UTXOs)</strong>. Think of a UTXO as a digital coin of a specific value sitting in a transparent lockbox. To spend it, you must prove you have the key that opens that specific box.</p>
<p>Your "balance" is not a number stored in a spreadsheet; it is an abstraction created by your wallet. The wallet scans the entire history of the blockchain, identifies every lockbox (UTXO) that it has the keys for, and sums their values together.</p>
<pre><code class="language-mermaid">graph LR
    subgraph YourWallet["Your Wallet (Conceptual)"]
        U1["UTXO 1&lt;br/&gt;0.5 BTC&lt;br/&gt;üîí Locked to Key A"]
        U2["UTXO 2&lt;br/&gt;0.3 BTC&lt;br/&gt;üîí Locked to Key A"]
        U3["UTXO 3&lt;br/&gt;1.2 BTC&lt;br/&gt;üîí Locked to Key B"]
    end
    
    subgraph Balance["Calculated Balance"]
        B["Total: 2.0 BTC"]
    end
    
    U1 --&gt; B
    U2 --&gt; B
    U3 --&gt; B
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-i-bitcoin-core-architecture"><a class="header" href="#part-i-bitcoin-core-architecture">Part I: Bitcoin Core Architecture</a></h1>
<h2 id="chapter-1-the-bitcoin-core-node-"><a class="header" href="#chapter-1-the-bitcoin-core-node-">Chapter 1: The Bitcoin Core Node ‚úÖ</a></h2>
<p>Bitcoin Core is the reference implementation of the Bitcoin protocol. It serves as the "Source of Truth" for what is considered a valid transaction or block. Understanding the node's internal structure is critical because it explains the performance limitations and safety guarantees you must navigate as a developer.</p>
<p>Historically, Bitcoin Core started as a monolithic C++ application where most logic resided in a single file (<code>main.cpp</code>). Over the last decade, it has evolved into a highly modular system of libraries, separated to improve testing, security, and build times.</p>
<h3 id="11-layered-architecture-"><a class="header" href="#11-layered-architecture-">1.1 Layered Architecture ‚ö†Ô∏è</a></h3>
<p>The node is divided into distinct functional areas. The <strong>P2P Layer</strong> handles the noisy reality of the internet‚Äîconnecting to peers and relaying data. The <strong>Validation Engine</strong> (Consensus) applies the strict rules of Bitcoin to everything the P2P layer receives. The <strong>Storage Layer</strong> persists this validated data efficiently to disk, while the <strong>RPC Layer</strong> provides a gateway for external applications to query state or submit new transactions.</p>
<pre><code class="language-mermaid">graph TB
    subgraph External["External Interface"]
        CLI["bitcoin-cli"]
        GUI["Bitcoin-Qt GUI"]
        API["JSON-RPC API"]
    end
    
    subgraph RPCLayer["RPC Layer (libevent2)"]
        RH["RPC Handlers (2 for RPC)"]
        REST["REST Handlers (12)"]
        RP["Request Parser"]
        RS["Response Serializer"]
    end
    
    subgraph Logic["Core Logic"]
        VAL["Validation Engine"]
        MEM["CTxMemPool"]
        CHAIN["ChainstateManager"]
        WALLET["CWallet + SPKMs"]
    end
    
    subgraph Storage["Storage Layer"]
        BLOCKS["BlockManager"]
        UTXODB["UTXO Set (LevelDB)"]
        WALLETDB["WalletDatabase"]
    end
    
    subgraph Network["P2P Network"]
        PEERS["PeerManager"]
        CONN["CConnman"]
        ADDR["AddrMan"]
        RELAY["Transaction Relay"]
    end
    
    CLI --&gt; API
    GUI --&gt; API
    API --&gt; RP
    RP --&gt; RH
    RH --&gt; VAL
    RH --&gt; MEM
    RH --&gt; WALLET
    VAL --&gt; CHAIN
    MEM --&gt; CHAIN
    CHAIN --&gt; BLOCKS
    CHAIN --&gt; UTXODB
    WALLET --&gt; WALLETDB
    PEERS --&gt; CONN
    CONN --&gt; ADDR
    MEM --&gt; RELAY
    RELAY --&gt; PEERS
</code></pre>
<h3 id="12-the-rpc-interface-"><a class="header" href="#12-the-rpc-interface-">1.2 The RPC Interface ‚úÖ</a></h3>
<p>The RPC (Remote Procedure Call) interface is the primary way developers interact with a running node. Unlike a simple REST API, the RPC server is designed for high-integrity interaction with the local process. Internally, Bitcoin Core uses <code>libevent2</code> to handle incoming HTTP requests asynchronously across multiple worker threads.</p>
<p>When you issue a command, it is parsed into a request object, placed into a global work queue (<code>g_work_queue</code>), and picked up by the next available worker thread to be executed against the core logic pointers.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant CLI as bitcoin-cli
    participant HTTP as HTTP Server (libevent2)
    participant WQ as WorkQueue
    participant Handler as RPC Handler
    participant Chain as Chain State
    
    CLI-&gt;&gt;HTTP: HTTP POST {"method": "getblockcount"}
    HTTP-&gt;&gt;HTTP: Create HTTPWorkItem
    HTTP-&gt;&gt;WQ: Add to global g_work_queue
    WQ-&gt;&gt;Handler: Worker thread processes
    Handler-&gt;&gt;Chain: Query chain tip height
    Chain--&gt;&gt;Handler: Return height (e.g., 850000)
    Handler-&gt;&gt;Handler: HTTPRequest::WriteReply()
    Handler--&gt;&gt;CLI: evhttp_send_reply() ‚Üí {"result": 850000}
</code></pre>
<h3 id="13-bitcoin-core-source-organization-"><a class="header" href="#13-bitcoin-core-source-organization-">1.3 Bitcoin Core Source Organization ‚ö†Ô∏è</a></h3>
<p>Navigating the <code>bitcoin/src/</code> directory requires understanding the internal library dependencies. The codebase is organized to prevent circular dependencies, with specialized libraries for consensus, networking, and wallet management.</p>
<blockquote>
<p><strong>Note</strong>: For developers, the <code>consensus/</code> folder is the most sacred, as any change there could accidentally fork your node away from the rest of the network.</p>
</blockquote>
<pre><code>bitcoin/src/
‚îú‚îÄ‚îÄ rpc/                    # RPC handlers (your external interface)
‚îú‚îÄ‚îÄ consensus/              # libbitcoin_consensus.a (standalone layer)
‚îú‚îÄ‚îÄ wallet/                 # libbitcoin_wallet.a (terminal dependency)
‚îú‚îÄ‚îÄ script/                 # Script interpreter and standard patterns
‚îú‚îÄ‚îÄ node/                   # libbitcoin_server.a (main node logic)
‚îú‚îÄ‚îÄ util/                   # General utility functions
‚îî‚îÄ‚îÄ net/                    # P2P and connection management
</code></pre>
<h3 id="14-signet-the-developers-testnet-"><a class="header" href="#14-signet-the-developers-testnet-">1.4 Signet: The Developer's Testnet ‚úÖ</a></h3>
<p>Developing on the live Bitcoin network (Mainnet) is expensive and risky. Traditional Testnet is often "unstable" because blocks can be mined very quickly (block storms) or very slowly. <strong>Signet</strong> solves this by using a centralized "signing" authority to produce blocks at predictable 10-minute intervals. This gives developers a stable, free environment that perfectly mimics the behavior of Mainnet without the volatility.</p>
<hr />
<h2 id="chapter-2-data-flow-through-bitcoin-core"><a class="header" href="#chapter-2-data-flow-through-bitcoin-core">Chapter 2: Data Flow Through Bitcoin Core</a></h2>
<h3 id="21-transaction-lifecycle-"><a class="header" href="#21-transaction-lifecycle-">2.1 Transaction Lifecycle ‚ö†Ô∏è</a></h3>
<p>Every transaction undergoes two distinct types of checks: <strong>Consensus</strong> and <strong>Policy</strong>. Consensus rules (e.g., "no double spending") are eternal and shared by all nodes. Policy rules (e.g., "minimum fee rate") are local preferences that help nodes protect their resources (RAM and CPU) from spam.</p>
<p>A transaction enters the system either from your wallet, an RPC call, or the P2P network. It must pass <code>AcceptToMemoryPool()</code> before it is eligible to be broadcast to other peers or included in a block by a miner.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Origins["Transaction Origins"]
        P2P["P2P Network&lt;br/&gt;(NetMsgType::TX)"]
        WALLET["Wallet"]
        RPCO["RPCs"]
    end
    
    subgraph MempoolPath["Mempool Path (Consensus + Policy)"]
        ATMP["AcceptToMemoryPool()"]
        CONS1["Consensus Checks"]
        POL["Policy Checks"]
        MEM["Add to CTxMemPool"]
    end
    
    subgraph BlockPath["Block Path (Consensus Only)"]
        BLOCK["NetMsgType::BLOCK"]
        CONS2["Consensus Checks Only"]
        SKIP["Skip Policy Checks"]
    end
    
    subgraph Propagation["3. Network Propagation"]
        INV["Announce to peers"]
        REQ["Peers request tx"]
        SEND["Send full transaction"]
    end
    
    subgraph Mining["4. Mining"]
        PICK["Miner selects tx"]
        MINE["Include in block"]
        POW["Proof of work"]
    end
    
    subgraph Confirmation["5. Confirmation"]
        BROAD["Broadcast block"]
        VAL2["Network validates"]
        UTXO["Update UTXO set"]
    end
    
    P2P --&gt; ATMP
    WALLET --&gt; ATMP
    RPCO --&gt; ATMP
    ATMP --&gt; CONS1 --&gt; POL --&gt; MEM
    
    BLOCK --&gt; CONS2 --&gt; SKIP --&gt; UTXO
    
    MEM --&gt; INV --&gt; REQ --&gt; SEND
    MEM --&gt; PICK --&gt; MINE --&gt; POW
    POW --&gt; BROAD --&gt; VAL2 --&gt; UTXO
</code></pre>
<h3 id="22-block-validation-process-"><a class="header" href="#22-block-validation-process-">2.2 Block Validation Process ‚ö†Ô∏è</a></h3>
<p>When a new block arrives, the node must perform a cascade of checks. The most expensive part of this is verifying every signature in every transaction. To optimize this, Bitcoin Core uses a <strong>Script Cache</strong>. If a transaction was already validated when it entered the mempool, the node remembers its validity and skips the duplicate work when that transaction finally appears in a block.</p>
<pre><code class="language-mermaid">graph TD
    B[New Block Arrives] --&gt; H{Header Valid?}
    H --&gt;|No| REJECT1[Reject Block]
    H --&gt;|Yes| POW{PoW Valid?}
    POW --&gt;|No| REJECT2[Reject Block]
    POW --&gt;|Yes| PARENT{Parent Block Known?}
    PARENT --&gt;|No| ORPHAN[Store as Orphan]
    PARENT --&gt;|Yes| TXS{All Transactions Valid?}
    TXS --&gt;|No| REJECT3[Reject Block]
    TXS --&gt;|Yes| UTXO{UTXO Rules Satisfied?}
    UTXO --&gt;|No| REJECT4[Reject Block]
    UTXO --&gt;|Yes| CACHE{Script in cache?}
    CACHE --&gt;|Yes| SKIPCACHE[Skip script check]
    CACHE --&gt;|No| SCRIPTS{All Scripts Pass?}
    SCRIPTS --&gt;|No| REJECT5[Reject Block]
    SCRIPTS --&gt;|Yes| ACCEPT[Accept Block]
    SKIPCACHE --&gt; ACCEPT
    ACCEPT --&gt; UPDATE[Update Chain State]
    UPDATE --&gt; RELAY[Relay to Peers]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-ii-cryptographic-foundations"><a class="header" href="#part-ii-cryptographic-foundations">Part II: Cryptographic Foundations</a></h1>
<h2 id="chapter-3-hash-functions-in-bitcoin-"><a class="header" href="#chapter-3-hash-functions-in-bitcoin-">Chapter 3: Hash Functions in Bitcoin ‚úÖ</a></h2>
<h3 id="31-the-role-of-hashing-"><a class="header" href="#31-the-role-of-hashing-">3.1 The Role of Hashing ‚úÖ</a></h3>
<p>At its core, Bitcoin is a giant chain of hash commitments. Hash functions allow us to take huge amounts of data (like a 2MB block) and represent it as a tiny, unique 32-byte string. This fingerprint is <strong>deterministic</strong> (always the same for the same data) and <strong>one-way</strong> (you can't reconstruct the block from the hash).</p>
<p>These properties are what make the blockchain immutable: if you change a single bit in a transaction, its hash changes, which changes the block's hash, which breaks the connection to every subsequent block in the chain.</p>
<pre><code class="language-mermaid">graph LR
    subgraph Input["Any Input"]
        I1["'Hello'"]
        I2["Entire block data"]
        I3["Transaction bytes"]
    end
    
    subgraph SHA256["SHA256 Function"]
        F["One-way transformation"]
    end
    
    subgraph Output["Fixed 32-byte Output"]
        O["256-bit hash"]
    end
    
    I1 --&gt; F
    I2 --&gt; F
    I3 --&gt; F
    F --&gt; O
</code></pre>
<h3 id="32-double-sha256-vs-single-sha256-"><a class="header" href="#32-double-sha256-vs-single-sha256-">3.2 Double SHA256 vs Single SHA256 ‚úÖ</a></h3>
<p>Bitcoin uses different hashing strategies for different contexts. <strong>Double SHA256</strong> (hashing the hash) was originally used by Satoshi to protect against potential future vulnerabilities in a single SHA256 pass. Modern upgrades like Taproot use <strong>Tagged Hashing</strong>, which prepends a domain-specific tag to the data to prevent "cross-protocol" attacks where a signature from one part of the system might be valid in another.</p>
<pre><code class="language-mermaid">graph TD
    subgraph DoubleSHA["Double SHA256 (Legacy)"]
        D1[Input] --&gt; D2["SHA256"]
        D2 --&gt; D3["SHA256 again"]
        D3 --&gt; D4["32-byte hash"]
    end
    
    subgraph SingleSHA["Single SHA256 (Taproot/BIP340)"]
        S1[Input] --&gt; S2["SHA256"]
        S2 --&gt; S3["32-byte hash"]
    end
    
    subgraph Tagged["Tagged Hash (BIP340)"]
        T1["tag + input"] --&gt; T2["SHA256(SHA256(tag) || SHA256(tag) || data)"]
        T2 --&gt; T3["32-byte hash"]
    end
</code></pre>
<hr />
<h2 id="chapter-4-elliptic-curve-cryptography-"><a class="header" href="#chapter-4-elliptic-curve-cryptography-">Chapter 4: Elliptic Curve Cryptography ‚úÖ</a></h2>
<h3 id="41-keys-without-the-math-"><a class="header" href="#41-keys-without-the-math-">4.1 Keys Without the Math ‚úÖ</a></h3>
<p>Elliptic Curve Cryptography (ECC) provides the "ownership" layer of Bitcoin. A <strong>Private Key</strong> is simply a secret random number. The <strong>Public Key</strong> is a coordinate on the <code>secp256k1</code> curve derived from that secret number. The "trapdoor" of ECC is that while it's easy to multiply a point to get a public key, it is mathematically impossible to "divide" to find the original secret number.</p>
<pre><code class="language-mermaid">graph LR
    subgraph Private["Private Key"]
        PK["256-bit random number&lt;br/&gt;(Keep secret!)"]
    end
    
    subgraph Public["Public Key"]
        PUB["Point on secp256k1 curve&lt;br/&gt;(Share freely)"]
    end
    
    subgraph Relationship["One-Way Relationship"]
        R["Easy: Private ‚Üí Public&lt;br/&gt;Impossible: Public ‚Üí Private"]
    end
    
    PK --&gt;|"Elliptic curve multiplication"| PUB
    PUB -.-&gt;|"Computationally infeasible"| PK
</code></pre>
<h3 id="42-key-formats-in-bitcoin-"><a class="header" href="#42-key-formats-in-bitcoin-">4.2 Key Formats in Bitcoin ‚úÖ</a></h3>
<p>As Bitcoin evolved, key serialization became more efficient. Standard SegWit uses <strong>Compressed Keys</strong> (33 bytes), while Taproot introduces <strong>X-only keys</strong> (32 bytes). By assuming the "Y" coordinate of the point is always even, we can discard it entirely, saving space on the blockchain and simplifying signature verification.</p>
<pre><code class="language-mermaid">graph TD
    subgraph PrivateKey["Private Key (32 bytes)"]
        SK["256-bit secret scalar"]
    end
    
    subgraph PublicKeyFormats["Public Key Formats"]
        FULL["Uncompressed (65 bytes)&lt;br/&gt;04 + x-coord + y-coord"]
        COMP["Compressed (33 bytes)&lt;br/&gt;02/03 + x-coord"]
        XONLY["X-only (32 bytes)&lt;br/&gt;Just x-coord"]
    end
    
    SK --&gt; FULL
    SK --&gt; COMP
    SK --&gt; XONLY
    
    FULL -.-&gt;|"Legacy"| L1["P2PKH addresses"]
    COMP -.-&gt;|"Standard"| L2["P2WPKH, P2SH"]
    XONLY -.-&gt;|"Taproot"| L3["P2TR addresses"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-iii-key-management--wallets"><a class="header" href="#part-iii-key-management--wallets">Part III: Key Management &amp; Wallets</a></h1>
<h2 id="chapter-5-hierarchical-deterministic-wallets-bip32-"><a class="header" href="#chapter-5-hierarchical-deterministic-wallets-bip32-">Chapter 5: Hierarchical Deterministic Wallets (BIP32) ‚úÖ</a></h2>
<h3 id="51-the-problem-hd-wallets-solve-"><a class="header" href="#51-the-problem-hd-wallets-solve-">5.1 The Problem HD Wallets Solve ‚úÖ</a></h3>
<p>In the early days of Bitcoin, every new address required a new random private key. If you lost your wallet file without backing up that <em>specific</em> key, your money was gone. <strong>Hierarchical Deterministic (HD) Wallets</strong> solved this by allowing an infinite number of keys to be derived from a single "Master Seed". One backup of 12 or 24 words can now recover your entire financial history forever.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Old["Random Key Generation"]
        R1["Key 1"] 
        R2["Key 2"]
        R3["Key 3"]
        R4["..."]
        B1["Backup: Save every key"]
    end
    
    subgraph HD["Hierarchical Deterministic"]
        SEED["Single Seed"]
        K1["Key 1"]
        K2["Key 2"]
        K3["Key 3"]
        K4["Infinite keys..."]
        B3["Backup: Just the seed"]
    end
    
    SEED --&gt; K1
    SEED --&gt; K2
    SEED --&gt; K3
    SEED --&gt; K4
</code></pre>
<h3 id="52-extended-keys-and-derivation-algorithm-"><a class="header" href="#52-extended-keys-and-derivation-algorithm-">5.2 Extended Keys and Derivation Algorithm ‚úÖ</a></h3>
<p>An <strong>Extended Key</strong> (xprv or xpub) is a standard key plus a 32-byte <strong>Chain Code</strong>. The Chain Code acts as extra entropy that allows us to derive child keys without exposing the parent's private key.</p>
<p><strong>Hardened Derivation</strong> (using the parent's private key) creates a firewall: even if a child key is compromised, it is mathematically impossible to climb back up and find the parent key. <strong>Normal Derivation</strong> allows an xpub to generate millions of child <em>public</em> keys, which is perfect for online shops that need a new address for every customer but never want to store a private key on a web server.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Input["Derivation Input"]
        PARENT["Parent Key + Chain Code"]
        INDEX["Child Index (32-bit)"]
        HARD{Hardened?}
    end
    
    subgraph HMAC["HMAC-SHA512"]
        H["Key: Parent Chain Code&lt;br/&gt;Data: [key data] || [index]"]
    end
    
    subgraph Output["64-byte Output"]
        LEFT["Left 32 bytes&lt;br/&gt;Add to parent key (mod n)"]
        RIGHT["Right 32 bytes&lt;br/&gt;New chain code"]
    end
    
    PARENT --&gt; HARD
    INDEX --&gt; HARD
    HARD --&gt;|"Yes: 0x00 || private key || index"| H
    HARD --&gt;|"No: compressed pubkey || index"| H
    H --&gt; LEFT
    H --&gt; RIGHT
    LEFT --&gt; CHILD["Child Private Key"]
    RIGHT --&gt; CHAIN["Child Chain Code"]
</code></pre>
<hr />
<h2 id="chapter-6-wallet-architecture-"><a class="header" href="#chapter-6-wallet-architecture-">Chapter 6: Wallet Architecture ‚ö†Ô∏è</a></h2>
<h3 id="61-scriptpubkeymanagers-spkm-"><a class="header" href="#61-scriptpubkeymanagers-spkm-">6.1 ScriptPubKeyManagers (SPKM) ‚ö†Ô∏è</a></h3>
<p>A modern Bitcoin wallet is actually a collection of specialized managers. Each <code>ScriptPubKeyMan</code> is responsible for a specific type of address (e.g., Taproot vs. Native SegWit). This modularity allows Bitcoin Core to support multiple address types simultaneously within the same wallet file while keeping the signing logic for each type isolated.</p>
<pre><code class="language-mermaid">graph TD
    subgraph CWallet["CWallet"]
        W["Wallet Container"]
    end
    
    subgraph SPKMs["ScriptPubKeyManagers (8 total for descriptor wallet)"]
        subgraph External["External (Receive)"]
            E1["LEGACY SPKM"]
            E2["P2SH-SEGWIT SPKM"]
            E3["BECH32 SPKM"]
            E4["BECH32M SPKM"]
        end
        subgraph Internal["Internal (Change)"]
            I1["LEGACY SPKM"]
            I2["P2SH-SEGWIT SPKM"]
            I3["BECH32 SPKM"]
            I4["BECH32M SPKM"]
        end
    end
    
    W --&gt; E1
    W --&gt; E2
    W --&gt; E3
    W --&gt; E4
    W --&gt; I1
    I3 --&gt; I4
</code></pre>
<h3 id="62-legacy-vs-descriptor-wallets-"><a class="header" href="#62-legacy-vs-descriptor-wallets-">6.2 Legacy vs Descriptor Wallets ‚ö†Ô∏è</a></h3>
<p>Bitcoin has moved from "Legacy" wallets (storing raw keys in a pool) to <strong>Descriptor Wallets</strong>. Descriptors are scripts that perfectly describe how to derive keys and construct addresses. They are unambiguous and portable, meaning you can move a descriptor between different wallet software (like Core to Sparrow) and always arrive at the exact same addresses and balance.</p>
<h3 id="63-wallet-recovery--blockchain-scanning-"><a class="header" href="#63-wallet-recovery--blockchain-scanning-">6.3 Wallet Recovery &amp; Blockchain Scanning ‚úÖ</a></h3>
<p>Recovering a wallet is one of the most resource-intensive tasks a node performs. Because the blockchain doesn't store "balances," the wallet must generate a significant number of keys (the "gap limit," usually 2000), calculate their corresponding addresses, and then read every block in the blockchain's history to see if any of those addresses ever received or spent money.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Scan["3. Blockchain Scan"]
        SET["Address Lookup Set"] --&gt; BLOCK["For each block 0..tip"]
        BLOCK --&gt; TX["For each transaction"]
        TX --&gt; CHECK["Check inputs and outputs"]
    end
    
    subgraph Track["4. UTXO Tracking"]
        CHECK --&gt; RECV["Output matches? Add UTXO"]
        CHECK --&gt; SPEND["Input matches? Remove UTXO"]
        RECV --&gt; BAL["Sum = Balance"]
    end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-iv-transactions-deep-dive"><a class="header" href="#part-iv-transactions-deep-dive">Part IV: Transactions Deep Dive</a></h1>
<h2 id="chapter-7-transaction-structure-"><a class="header" href="#chapter-7-transaction-structure-">Chapter 7: Transaction Structure ‚úÖ</a></h2>
<h3 id="71-anatomy-of-a-bitcoin-transaction-"><a class="header" href="#71-anatomy-of-a-bitcoin-transaction-">7.1 Anatomy of a Bitcoin Transaction ‚úÖ</a></h3>
<p>A Bitcoin transaction is a data package that takes existing UTXOs (inputs) and re-locks them into new conditions (outputs). Every input must point back to a specific <code>COutPoint</code> (the TXID and index of a previous output) and provide a valid signature. Every output specifies an amount in Satoshis and a <code>scriptPubKey</code>, which contains the locking instructions.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Header["Transaction Header"]
        VER["Version (4 bytes)"]
        MARKER["Marker + Flag (SegWit)"]
    end
    
    subgraph InputDetail["Inputs (CTxIn)"]
        PREV["COutPoint (TXID:vout)"]
        SCRIPT["scriptSig"]
        SEQ["nSequence"]
        WIT["scriptWitness"]
    end
    
    subgraph OutputDetail["Outputs (CTxOut)"]
        VAL["nValue (Satoshis)"]
        SPK["scriptPubKey"]
    end
    
    VER --&gt; MARKER --&gt; INCNT --&gt; PREV --&gt; OUTCNT --&gt; VAL --&gt; W1 --&gt; LOCK
</code></pre>
<h3 id="72-segwit-separating-witness-data-"><a class="header" href="#72-segwit-separating-witness-data-">7.2 SegWit: Separating Witness Data ‚úÖ</a></h3>
<p><strong>Segregated Witness (SegWit)</strong> was a revolutionary upgrade that moved the signature (witness) data out of the main transaction structure. This fixed a critical bug called "Transaction Malleability," where anyone could slightly change a signature and change the TXID of a transaction before it was confirmed. By pulling the witness out, the TXID remains stable, which is necessary for advanced technologies like the Lightning Network.</p>
<hr />
<h2 id="chapter-8-script-system-"><a class="header" href="#chapter-8-script-system-">Chapter 8: Script System ‚ö†Ô∏è</a></h2>
<h3 id="81-bitcoin-script-basics-"><a class="header" href="#81-bitcoin-script-basics-">8.1 Bitcoin Script Basics ‚úÖ</a></h3>
<p>Bitcoin uses a "Forth-like" stack-based language. It is intentionally simple and <strong>not Turing-complete</strong>, meaning it has no loops. This is a security feature: it ensures that a script will always finish executing in a predictable amount of time, protecting the network from "infinite loop" denial-of-service attacks.</p>
<h3 id="82-execution-and-validation-flow-"><a class="header" href="#82-execution-and-validation-flow-">8.2 Execution and Validation Flow ‚ö†Ô∏è</a></h3>
<p>In modern Bitcoin (since 2010), the input and output scripts are not simply concatenated and run together. Instead, the input script is executed first, and the resulting "stack" is then passed to the output script. If the output script finishes with a "True" value on the stack, the transaction is valid.</p>
<pre><code class="language-mermaid">graph TD
    subgraph PreChecks["Validation Stages"]
        PC["Standardness Checks"]
        POL["Policy Checks (Mempool)"]
        VS["VerifyScript (Consensus)"]
    end
    
    PC --&gt; POL --&gt; VS
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-v-taproot--modern-bitcoin"><a class="header" href="#part-v-taproot--modern-bitcoin">Part V: Taproot &amp; Modern Bitcoin</a></h1>
<h2 id="chapter-9-understanding-taproot-"><a class="header" href="#chapter-9-understanding-taproot-">Chapter 9: Understanding Taproot ‚úÖ</a></h2>
<h3 id="91-the-taproot-vision-"><a class="header" href="#91-the-taproot-vision-">9.1 The Taproot Vision ‚úÖ</a></h3>
<p>Taproot is the most significant upgrade to Bitcoin since SegWit. Its primary goal is privacy and efficiency through <strong>Mast (Merkelized Alternative Script Trees)</strong> and <strong>Schnorr Signatures</strong>. In Taproot, a user can have multiple ways to spend their money: a simple signature (Key Path) OR a complex set of conditions (Script Path). On-chain, a Key Path spend looks identical to any other Taproot spend, hiding the fact that other conditions even existed.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Output["Taproot Output"]
        PROG["OP_1 &lt;output_key&gt;"]
    end
    
    subgraph Paths["Spending Paths"]
        KEY["Key Path (Private)"]
        SCRIPT["Script Path (Flexible)"]
    end
    
    Output --&gt; KEY
    Output --&gt; SCRIPT
</code></pre>
<h3 id="92-taproot-key-structure-"><a class="header" href="#92-taproot-key-structure-">9.2 Taproot Key Structure ‚úÖ</a></h3>
<p>The magic of Taproot lies in <strong>Key Tweaking</strong>. We take an "Internal Key" (P) and modify it by adding a hash of the "Script Tree" (T). The resulting "Output Key" (Q) commits to both the key and the scripts. To spend via the Key Path, you tweak your private key in the same way. To spend via the Script Path, you reveal the script and prove it was part of the original commitment.</p>
<pre><code class="language-mermaid">graph TD
    subgraph Tweak["Tweak Computation"]
        INT["Internal Key (P)"]
        TREE["Script Tree"]
        TAGGED["t = tagged_hash('TapTweak', P || merkle_root)"]
        OUT["Q = P + t*G"]
    end
    
    INT --&gt; TAGGED
    TREE --&gt; TAGGED
    TAGGED --&gt; OUT
</code></pre>
<hr />
<h2 id="chapter-10-taproot-signatures-bip341-"><a class="header" href="#chapter-10-taproot-signatures-bip341-">Chapter 10: Taproot Signatures (BIP341) ‚úÖ</a></h2>
<h3 id="101-the-commitment-hash-"><a class="header" href="#101-the-commitment-hash-">10.1 The Commitment Hash ‚úÖ</a></h3>
<p>Signing for Taproot requires a much more complex "Signature Hash" (Sighash) than legacy types. It includes references to all inputs and their values to prevent "fee-sniping" and other subtle attacks. This commitment hash is what the Schnorr algorithm actually signs.</p>
<h3 id="102-key-path-vs-script-path-signing-"><a class="header" href="#102-key-path-vs-script-path-signing-">10.2 Key Path vs Script Path Signing ‚úÖ</a></h3>
<ul>
<li><strong>Key Path</strong>: The wallet tweaks the private key, checks the Y-coordinate parity (negating the key if necessary), and creates a single 64-byte signature.</li>
<li><strong>Script Path</strong>: The wallet reveals the specific script, provides a Merkle proof (the Control Block), and signs with untweaked keys as defined in that script.</li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
    participant W as Wallet
    participant K as Private Key
    participant S as Signature
    
    W-&gt;&gt;W: Compute TapSighash
    W-&gt;&gt;K: Tweak Key + Check Parity
    K-&gt;&gt;S: Schnorr Sign
    S-&gt;&gt;W: 64-byte Sig
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-vi-practical-implementation-patterns"><a class="header" href="#part-vi-practical-implementation-patterns">Part VI: Practical Implementation Patterns</a></h1>
<h2 id="chapter-12-coin-selection-"><a class="header" href="#chapter-12-coin-selection-">Chapter 12: Coin Selection ‚ö†Ô∏è</a></h2>
<h3 id="121-the-coin-selection-problem-"><a class="header" href="#121-the-coin-selection-problem-">12.1 The Coin Selection Problem ‚úÖ</a></h3>
<p>When you want to pay someone 0.1 BTC, your wallet might have dozens of UTXOs of various sizes (0.05, 0.2, 0.01...). <strong>Coin Selection</strong> is the algorithm that decides which specific "coins" to use. This is a variation of the "Knapsack Problem," but with an added twist: we must also consider the privacy implications of creating "change" and the cost (fees) of including more inputs.</p>
<h3 id="123-the-three-algorithms-"><a class="header" href="#123-the-three-algorithms-">12.3 The Three Algorithms ‚ö†Ô∏è</a></h3>
<p>Contrary to popular belief, Bitcoin Core uses three distinct strategies to find the best set of coins, choosing the one that results in the lowest <strong>Waste Metric</strong>.</p>
<ol>
<li><strong>Branch and Bound (BnB)</strong>: Tries to find an <em>exact match</em> for the payment so that no change output is needed. This is the most efficient for privacy and fees.</li>
<li><strong>Knapsack</strong>: The legacy strategy that picks coins somewhat randomly to provide privacy.</li>
<li><strong>Single Random Draw (SRD)</strong>: A simple fallback that picks coins until the target is met.</li>
</ol>
<pre><code class="language-mermaid">graph TD
    subgraph Selection["Waste Metric Selection"]
        BNB["BnB (Exact Match)"]
        KNAP["Knapsack"]
        SRD["SRD"]
        WASTE["Best = Lowest Waste"]
    end
    
    BNB --&gt; WASTE
    KNAP --&gt; WASTE
    SRD --&gt; WASTE
</code></pre>
<hr />
<h2 id="chapter-13-transaction-building-"><a class="header" href="#chapter-13-transaction-building-">Chapter 13: Transaction Building ‚ö†Ô∏è</a></h2>
<p>Building a transaction is a multi-step process that requires careful locking of the wallet state. Before selecting coins, the wallet must acquire the <code>cs_wallet</code> lock to ensure no other thread tries to spend the same coins at the same time. It then creates a "dummy" version of the transaction to calculate the exact size and fee, before finally producing the real signatures.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant W as Wallet
    participant CS as Coin Selection
    participant SPKM as SPKM
    
    W-&gt;&gt;W: Lock cs_wallet
    W-&gt;&gt;CS: AvailableCoins()
    CS-&gt;&gt;W: List Spendable UTXOs
    W-&gt;&gt;CS: Choose via Waste Metric
    W-&gt;&gt;SPKM: Sign for Inputs
    W-&gt;&gt;W: testmempoolaccept
    W-&gt;&gt;W: Broadcast
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-quick-reference"><a class="header" href="#appendix-quick-reference">Appendix: Quick Reference</a></h1>
<h2 id="a-bip-standards-summary"><a class="header" href="#a-bip-standards-summary">A. BIP Standards Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>BIP</th><th>Name</th><th>Purpose</th></tr></thead><tbody>
<tr><td>BIP32</td><td>HD Wallets</td><td>Deterministic key derivation from seed</td></tr>
<tr><td>BIP86</td><td>Taproot Single Key</td><td>Standard derivation path for single-key Taproot</td></tr>
<tr><td>BIP341</td><td>Taproot</td><td>The rules for SegWit v1 outputs</td></tr>
<tr><td>BIP342</td><td>Tapscript</td><td>The new opcodes for Taproot scripts</td></tr>
</tbody></table>
</div>
<h2 id="b-conceptual-glossary"><a class="header" href="#b-conceptual-glossary">B. Conceptual Glossary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Conceptual Definition</th></tr></thead><tbody>
<tr><td><strong>UTXO</strong></td><td>An unspent coin waiting in a lockbox on the blockchain.</td></tr>
<tr><td><strong>Outpoint</strong></td><td>The unique ID of a UTXO (TXID + output index).</td></tr>
<tr><td><strong>Witness</strong></td><td>The signature data, kept separate from the transaction to fix malleability.</td></tr>
<tr><td><strong>Tweak</strong></td><td>A mathematical shift applied to a key to commit to a script tree.</td></tr>
<tr><td><strong>Dust</strong></td><td>An output so small it's worth less than the fee required to spend it.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
